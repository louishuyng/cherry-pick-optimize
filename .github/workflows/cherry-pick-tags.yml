name: Cherry Pick Missing Tags
on:
  workflow_dispatch:
    inputs:
      tag_prefix:
        description: 'Tag prefix to search for (e.g., REG-1234)'
        required: true
        type: string
      target_branch:
        description: 'Target branch to cherry-pick into'
        required: true
        type: choice
        options:
          - staging
        default: staging
      source_branch:
        description: 'Source branch to cherry-pick from'
        required: true
        type: choice
        options:
          - main
        default: main
jobs:
  cherry-pick-missing-tags:
    permissions:
      contents: write
      pull-requests: write
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
      - name: Setup and find missing tags
        id: find-missing
        run: |
          set -e

          # Fetch all data
          git fetch --all --tags
          git checkout ${{ inputs.target_branch }}
          git pull origin ${{ inputs.target_branch }}

          echo "Searching for tags with prefix: ${{ inputs.tag_prefix }}"

          # Get tags with specified prefix from both branches
          source_tags=$(git tag --merged origin/${{ inputs.source_branch }} | grep "^${{ inputs.tag_prefix }}\." | sort -V || true)
          target_tags=$(git tag --merged origin/${{ inputs.target_branch }} | grep "^${{ inputs.tag_prefix }}\." | sort -V || true)

          echo "Source tags: $source_tags"
          echo "Target tags: $target_tags"

          # Find missing tags
          missing_tags=""
          if [ -n "$source_tags" ]; then
            for tag in $source_tags; do
              if ! echo "$target_tags" | grep -q "^$tag$"; then
                missing_tags="$missing_tags$tag "
              fi
            done
          fi

          missing_tags=$(echo $missing_tags | xargs)  # trim whitespace

          if [ -n "$missing_tags" ]; then
            echo "has_missing=true" >> $GITHUB_OUTPUT
            # Sort missing tags by version number (small to large)
            echo "$missing_tags" | tr ' ' '\n' | sort -V > missing_tags.txt
            echo "missing_count=$(echo $missing_tags | wc -w)" >> $GITHUB_OUTPUT
            echo "Found missing tags (will be processed in version order): $missing_tags"
          else
            echo "has_missing=false" >> $GITHUB_OUTPUT
            echo "missing_count=0" >> $GITHUB_OUTPUT
            echo "No missing tags found"
          fi
      - name: Cherry-pick missing tags
        id: cherry-pick
        if: steps.find-missing.outputs.has_missing == 'true'
        run: "set -e\n\nBASE_BRANCH_NAME=\"cherry-pick/${{ inputs.tag_prefix }}-to-${{ inputs.target_branch }}\"\nBRANCH_NAME=\"$BASE_BRANCH_NAME\"\n\n# Check if branch already exists and add suffix if needed\ncounter=1\nwhile git ls-remote --heads origin \"$BRANCH_NAME\" | grep -q \"$BRANCH_NAME\"; do\n  BRANCH_NAME=\"${BASE_BRANCH_NAME}-${counter}\"\n  counter=$((counter + 1))\ndone\n\necho \"üåø Creating new branch: $BRANCH_NAME from ${{ inputs.target_branch }}\"\ngit checkout -b \"$BRANCH_NAME\" origin/${{ inputs.target_branch }}\n\necho \"üìã Reading missing tags (sorted by version order)...\"\nsuccess_tags=\"\"\nconflicted_tags=\"\"\nfailed_tags=\"\"\ntotal_tags=0\n\n# Process tags one by one from the sorted file (version order: small to large)\nwhile IFS= read -r tag; do\n  if [ -n \"$tag\" ]; then\n    total_tags=$((total_tags + 1))\n    echo \"\"\n    echo \"üè∑Ô∏è  Processing tag [$total_tags]: $tag\"\n    \n    # Get the commit hash for this tag\n    tag_commit=$(git rev-list -n 1 \"$tag\")\n    echo \"   Commit: $tag_commit\"\n    \n    # Attempt cherry-pick\n    if git cherry-pick \"$tag_commit\"; then\n      echo \"   ‚úÖ Successfully cherry-picked $tag\"\n      success_tags=\"$success_tags$tag \"\n    else\n      # Check if it's a merge conflict or other error\n      if git status --porcelain | grep -q \"^UU\\|^AA\\|^DD\\|^AU\\|^UA\\|^DU\\|^UD\"; then\n        echo \"   ‚ö†Ô∏è  Merge conflict detected for $tag\"\n        echo \"   üìù Committing conflict markers for manual resolution...\"\n        \n        # Add all files (including conflicted ones)\n        git add .\n        \n        # Create a commit with conflict markers\n        git commit -m \"Cherry-pick $tag (CONFLICTS - manual resolution needed)\n        \nOriginal commit: $tag_commit\nTag: $tag\n\n‚ö†Ô∏è  This commit contains merge conflicts that need manual resolution.\nConflicted files are marked with <<<<<<< HEAD, =======, and >>>>>>> markers.\nPlease resolve conflicts and amend this commit.\"\n        \n        echo \"   ‚úÖ Committed with conflict markers for $tag\"\n        conflicted_tags=\"$conflicted_tags$tag \"\n      else\n        echo \"   ‚ùå Failed to cherry-pick $tag (non-conflict error)\"\n        failed_tags=\"$failed_tags$tag \"\n        git cherry-pick --abort || true\n      fi\n    fi\n  fi\ndone < missing_tags.txt\n\n# Store results for PR step\necho \"$success_tags\" > success_tags.txt\necho \"$conflicted_tags\" > conflicted_tags.txt\necho \"$failed_tags\" > failed_tags.txt\n\nsuccess_count=$(echo $success_tags | wc -w)\nconflicted_count=$(echo $conflicted_tags | wc -w)\nfailed_count=$(echo $failed_tags | wc -w)\nprocessed_count=$((success_count + conflicted_count))\n\necho \"\"\necho \"üìä Cherry-pick Summary:\"\necho \"   Total processed: $total_tags\"\necho \"   ‚úÖ Successful: $success_count\"\necho \"   ‚ö†Ô∏è  With conflicts: $conflicted_count\"\necho \"   ‚ùå Failed: $failed_count\"\n\nif [ $processed_count -gt 0 ]; then\n  echo \"\"\n  echo \"üöÄ Pushing branch to remote...\"\n  git push origin \"$BRANCH_NAME\"\n  echo \"branch_created=true\" >> $GITHUB_OUTPUT\n  echo \"branch_name=$BRANCH_NAME\" >> $GITHUB_OUTPUT\n  echo \"‚úÖ Branch pushed successfully!\"\nelse\n  echo \"‚ùå No successful cherry-picks or conflicts to resolve, not creating branch\"\n  echo \"branch_created=false\" >> $GITHUB_OUTPUT\n  exit 1\nfi\n"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Prepare PR body
        if: steps.find-missing.outputs.has_missing == 'true'
        run: |
          success_tags=$(cat success_tags.txt | xargs)
          conflicted_tags=$(cat conflicted_tags.txt | xargs)
          failed_tags=$(cat failed_tags.txt | xargs)
          success_count=$(echo $success_tags | wc -w)
          conflicted_count=$(echo $conflicted_tags | wc -w)
          failed_count=$(echo $failed_tags | wc -w)

          # Build PR body dynamically
          cat > pr_body.md << 'EOF'
          ## Cherry-pick Summary

          This PR cherry-picks missing tags with prefix `${{ inputs.tag_prefix }}` from `${{ inputs.source_branch }}` to `${{ inputs.target_branch }}`.

          ### Results
          - ‚úÖ Successful: $success_count
          - ‚ö†Ô∏è  With conflicts: $conflicted_count
          - ‚ùå Failed: $failed_count

          ### Configuration
          - **Tag prefix**: `${{ inputs.tag_prefix }}`
          - **Source branch**: `${{ inputs.source_branch }}`
          - **Target branch**: `${{ inputs.target_branch }}`
          EOF

          # Add successful tags section
          if [ -n "$success_tags" ]; then
            cat >> pr_body.md << EOF

          ### Successfully cherry-picked:
          \`\`\`
          $(echo "$success_tags" | tr ' ' '\n')
          \`\`\`
          EOF
          fi

          # Add conflicted tags section
          if [ -n "$conflicted_tags" ]; then
            cat >> pr_body.md << 'EOF'

          ### Tags with conflicts (‚ö†Ô∏è  MANUAL RESOLUTION REQUIRED):
          ```
          EOF
            echo "$conflicted_tags" | tr ' ' '\n' >> pr_body.md
            cat >> pr_body.md << 'EOF'
          ```

          **üîß How to resolve conflicts:**
          1. Check out this PR branch locally
          2. Look for commits with "CONFLICTS" in the message
          3. Find files with conflict markers: `<<<<<<<`, `=======`, `>>>>>>>`
          4. Resolve conflicts by choosing the correct code
          5. Remove conflict markers
          6. Stage the resolved files: `git add <file>`
          7. Amend the conflict commit: `git commit --amend`
          8. Push the changes: `git push --force-with-lease`

          **üîç Find conflicted files:**
          ```bash
          # Search for conflict markers in the repository
          grep -r "<<<<<<< HEAD" .
          grep -r "=======" .
          grep -r ">>>>>>>" .
          ```
          EOF
          fi

          # Add failed tags section
          if [ -n "$failed_tags" ]; then
            cat >> pr_body.md << 'EOF'

          ### Failed tags (non-conflict errors):
          ```
          EOF
            echo "$failed_tags" | tr ' ' '\n' >> pr_body.md
            cat >> pr_body.md << 'EOF'
          ```

          These tags failed due to non-conflict errors and were not included in this PR. Manual investigation may be required.
          EOF
          fi

          cat >> pr_body.md << 'EOF'

          ---
          ü§ñ *Auto-generated by Cherry Pick workflow*
          EOF
      - name: Create Pull Request
        if: steps.find-missing.outputs.has_missing == 'true'
        uses: peter-evans/create-pull-request@v7
        with:
          branch: ${{ steps.cherry-pick.outputs.branch_name }}
          title: "Cherry-pick ${{ inputs.tag_prefix }}.* tags to ${{ inputs.target_branch }}"
          body-path: pr_body.md
          base: ${{ inputs.target_branch }}
      - name: No missing tags
        if: steps.find-missing.outputs.has_missing == 'false'
        run: |
          echo "‚úÖ No missing tags found!"
          echo "All tags with prefix '${{ inputs.tag_prefix }}' are already in '${{ inputs.target_branch }}'."
